<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CTP Page Monitor - Mobile Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --color-bg-primary: #0f0f12;
      --color-bg-secondary: #1a1a1f;
      --color-bg-card: #25252d;
      --color-text-light: #e0e0e0;
      --color-text-dim: #a0a0a0;
      --color-accent-blue: #0077b6;
      --color-accent-cyan: #00b4d8;
      --color-accent-yellow: #ffb703;
      --color-accent-red: #e63946;
      --color-accent-green: #3c9f3c;
      --color-issue-text: #66cc66;
      --color-edition-title-bg: #0077b6;
      --color-section-title-bg: #33333d;
      --color-status-ok: #1cc88a;
      --color-status-fail: #f6c23e;
      --color-status-wait: #e74a3b;
      --color-section-title: #f8f9fa;
      --color-border: #33333d;
      --border-radius: 3px;
      --spacing-unit: 6px;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--color-bg-primary);
      color: var(--color-text-light);
      padding: var(--spacing-unit);
      font-size: 0.833em;
      line-height: 1.3;
    }

    .header-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--color-bg-secondary);
      padding: var(--spacing-unit);
      border-radius: var(--border-radius);
      margin-bottom: var(--spacing-unit);
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
    }
    
    .title {
      color: var(--color-accent-yellow);
      font-weight: normal;
      font-size: 1.3em;
    }
    
    .nav-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .nav-btn {
      background: var(--color-accent-blue);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      padding: 6px 10px;
      cursor: pointer;
      font-size: 0.95em;
    }
    
    .nav-btn:disabled {
      background: var(--color-bg-card);
      color: var(--color-text-dim);
      cursor: not-allowed;
    }
    
    .current-date {
      font-weight: bold;
      color: var(--color-accent-yellow);
      min-width: 80px;
      text-align: center;
    }

    /* FIXED: Tabs styling - more compact for mobile */
    .tabs-container {
      display: flex;
      overflow-x: auto;
      background: var(--color-bg-secondary);
      border-radius: var(--border-radius);
      margin-bottom: var(--spacing-unit);
      scrollbar-width: none; /* Firefox */
      padding: 0 2px; /* Reduced padding */
    }
    
    .tabs-container::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Edge */
    }
    
    .tab {
      flex: 1;
      min-width: 70px; /* Reduced from 80px */
      padding: 6px 8px; /* Reduced padding */
      text-align: center;
      background: var(--color-bg-secondary);
      color: var(--color-text-dim);
      border: none;
      cursor: pointer;
      font-size: 0.85em; /* Smaller font */
      white-space: nowrap;
      transition: all 0.2s;
      margin: 0 1px; /* Reduced margin */
    }
    
    .tab.active {
      background: var(--color-accent-blue);
      color: white;
      font-weight: bold;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }

    .container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--spacing-unit);
    }

    .card {
      background: var(--color-bg-card);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      padding: 0;
      overflow: hidden;
      margin-bottom: var(--spacing-unit);
    }

    .card h3 {
      margin: 0;
      padding: 6px 8px;
      background: var(--color-edition-title-bg);
      color: white;
      font-weight: normal;
      font-size: 1.05em;
      text-transform: uppercase;
    }

    .checklist-table {
      width: 100%;
      font-size: 0.9em;
      border-collapse: collapse;
    }
    
    .checklist-table td {
      padding: 3px;
      border-bottom: 1px solid #2f2f38;
    }
    
    .checklist-table tr:last-child td { 
      border-bottom: none; 
    }

    .filename-col {
      width: 15%;
      white-space: nowrap;
    }
    
    .title-col {
      width: 43%;
    }
    
    .edit-col, .icd-col { 
      width: 7%; 
      text-align: center; 
    }
    
    .status-col { 
      width: 3%; 
      text-align: center; 
    }
    
    .time-col { 
      width: 25%; 
      text-align: right; 
      color: var(--color-text-dim); 
    }

    .issue-group-title-row td, .pullout-group-title-row td {
      padding: 4px 8px !important;
      font-weight: normal;
      font-size: 1em;
      color: var(--color-section-title);
      background: var(--color-section-title-bg);
      border-bottom: 1px solid var(--color-border) !important;
      column-span: 6;
    }
    
    .pullout-group-title-row td {
      color: #c0c0ff;
      background: #3d3345;
    }

    /* STATUS DOTS - CORRECTED COLORS */
    .status-dot {
      display: inline-block;
      width: 7px;
      height: 7px;
      border-radius: 50%;
      vertical-align: middle;
    }
    
    .status-ok { 
      background-color: var(--color-status-ok); /* Green */
    }
    
    .status-no { 
      background-color: var(--color-status-fail); /* Red */
    }
    
    .status-wait { 
      background-color: var(--color-status-wait); /* Yellow */
    }

    .error {
      background: #3d0000;
      color: #ffcccc;
      padding: 6px 8px;
      border-radius: 3px;
      border-left: 4px solid var(--color-accent-red);
      margin-bottom: 6px;
      font-size: 0.95em;
    }

    .loading {
      text-align: center;
      padding: 20px;
      color: var(--color-text-dim);
    }
    
    .sync-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 5px;
    }
    
    .sync-active {
      background-color: var(--color-status-ok);
      animation: pulse 1s infinite;
    }
    
    .sync-idle {
      background-color: var(--color-text-dim);
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="header-bar">
    <div class="title">CTP Page Monitor</div>
    <div class="nav-controls">
      <button id="prev-date-btn" class="nav-btn" disabled>←</button>
      <div id="current-date" class="current-date">Loading...</div>
      <button id="next-date-btn" class="nav-btn" disabled>→</button>
    </div>
  </div>

  <div id="tabs-container" class="tabs-container">
    <!-- Tabs will be dynamically generated -->
  </div>

  <div id="errorContainer"></div>
  <div id="loadingMessage" class="loading">Loading data...</div>
  
  <!-- Tab content containers -->
  <div id="tab-kokan" class="tab-content"></div>
  <div id="tab-satara" class="tab-content"></div>
  <div id="tab-sangli" class="tab-content"></div>
  <div id="tab-kolhapur" class="tab-content"></div>
  <div id="tab-pullout" class="tab-content"></div>

  <script>
    // Configuration - Hardcoded GAS URL
    const GAS_URL = "https://script.google.com/macros/s/AKfycbwdQS74XocwdoPNO5EhaHzvamil3BtQLZFKHkylngLxIPmNlMeS9gYLYEyMSioqbr-g/exec";
    let availableDates = [];
    let currentDateIndex = -1;
    let currentDatePrefix = '';
    let syncIntervalId = null;
    let currentActiveTab = 'kokan';

    // DOM Elements
    const prevDateBtn = document.getElementById('prev-date-btn');
    const nextDateBtn = document.getElementById('next-date-btn');
    const currentDateEl = document.getElementById('current-date');
    const errorContainer = document.getElementById('errorContainer');
    const loadingMessage = document.getElementById('loadingMessage');
    const tabsContainer = document.getElementById('tabs-container');

    // Format date for display
    function formatDisplayDate(dateStr) {
      if (!dateStr || dateStr.length !== 8) return 'N/A';
      return `${dateStr.substring(0, 2)}/${dateStr.substring(2, 4)}/${dateStr.substring(4, 8)}`;
    }

    // Show error message
    function showError(msg) {
      errorContainer.innerHTML = `<div class="error">${msg}</div>`;
      console.warn(msg);
    }

    // Clear error message
    function clearError() {
      errorContainer.innerHTML = '';
    }

    // Show loading state
    function showLoading(message) {
      loadingMessage.textContent = message;
      loadingMessage.style.display = 'block';
      hideAllTabContents();
    }

    // Hide loading state
    function hideLoading() {
      loadingMessage.style.display = 'none';
    }

    // Hide all tab contents
    function hideAllTabContents() {
      const tabContents = document.querySelectorAll('.tab-content');
      tabContents.forEach(tab => tab.classList.remove('active'));
    }

    // Clear all tab contents
    function clearAllTabContents() {
      const tabContents = document.querySelectorAll('.tab-content');
      tabContents.forEach(tab => {
        tab.innerHTML = '';
      });
    }

    // Initialize tabs
    function initializeTabs() {
      const tabs = [
        { id: 'kokan', label: 'Kokan' },
        { id: 'satara', label: 'Satara' },
        { id: 'sangli', label: 'Sangli' },
        { id: 'kolhapur', label: 'Kolhapur' },
        { id: 'pullout', label: 'Pullout' }
      ];
      
      tabsContainer.innerHTML = '';
      
      tabs.forEach(tab => {
        const tabElement = document.createElement('button');
        tabElement.className = 'tab';
        tabElement.id = `tab-${tab.id}-btn`;
        tabElement.textContent = tab.label;
        tabElement.addEventListener('click', () => switchTab(tab.id));
        tabsContainer.appendChild(tabElement);
      });
      
      // Restore active tab from localStorage or default to first tab
      const savedTab = localStorage.getItem('ctp-active-tab');
      if (savedTab && document.getElementById(`tab-${savedTab}-btn`)) {
        switchTab(savedTab);
      } else {
        switchTab('kokan');
      }
    }

    // Switch to a specific tab
    function switchTab(tabId) {
      // Deactivate all tabs
      const allTabs = document.querySelectorAll('.tab');
      allTabs.forEach(tab => tab.classList.remove('active'));
      
      // Hide all tab contents
      hideAllTabContents();
      
      // Activate selected tab
      const selectedTab = document.getElementById(`tab-${tabId}-btn`);
      if (selectedTab) {
        selectedTab.classList.add('active');
      }
      
      // Show selected tab content
      const selectedContent = document.getElementById(`tab-${tabId}`);
      if (selectedContent) {
        selectedContent.classList.add('active');
      }
      
      // Save active tab to localStorage
      currentActiveTab = tabId;
      localStorage.setItem('ctp-active-tab', tabId);
    }

    // CORRECTED: Render status dot based on status value
    function renderStatusDot(status) {
      if (!status) status = "Wait";
      const s = status.toLowerCase();
      let cls = "status-wait";
      if (s === "ok") cls = "status-ok";
      else if (s === "no") cls = "status-no";
      return `<span class="status-dot ${cls}" title="${status}"></span>`;
    }

    // Fetch default date from Google Sheets Settings
    async function fetchDefaultDate() {
      try {
        const url = `${GAS_URL}?action=getDefaultDate`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        
        const json = await res.json();
        if (json.status === 'success' && json.default_date) {
          return json.default_date;
        }
        throw new Error('Invalid default date response');
      } catch (err) {
        console.error('Failed to fetch default date:', err);
        // Fallback to today's date
        const today = new Date();
        return String(today.getDate()).padStart(2, '0') + 
               String(today.getMonth() + 1).padStart(2, '0') + 
               today.getFullYear();
      }
    }

    // Fetch available dates from Google Apps Script
    async function fetchAvailableDates() {
      try {
        const url = `${GAS_URL}?action=listDates`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        
        const json = await res.json();
        if (json.status === 'success' && Array.isArray(json.dates)) {
          return json.dates;
        } else {
          throw new Error(json.message || 'Invalid response format');
        }
      } catch (err) {
        console.error('Failed to fetch dates:', err);
        throw new Error(`Failed to load dates: ${err.message}`);
      }
    }

    // Load edition-specific data for a specific date
    async function loadEditionDataForDate(datePrefix, edition) {
      try {
        const url = `${GAS_URL}?action=getEditionData&date=${datePrefix}&edition=${edition}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        
        const json = await res.json();
        if (json.status === 'success') {
          let userData = {};
          try {
            userData = JSON.parse(json.user_data || "{}");
          } catch (parseError) {
            console.warn(`Failed to parse user_data for ${edition}:`, parseError);
            userData = {};
          }
          
          return {
            edition: edition,
            user_data: userData,
            saved_at: json.saved_at || ""
          };
        } else {
          throw new Error(json.message || 'Invalid edition data response');
        }
      } catch (err) {
        console.error(`Failed to load ${edition} data:`, err);
        return {
          edition: edition,
          user_data: {},
          saved_at: ""
        };
      }
    }

    // Load all edition data for a specific date and combine into unified structure
    async function loadAllEditionData(datePrefix) {
      const editions = ['01Kokan', '02Satara', '03Sangli', '04Kolhapur', '05Pullout'];
      const promises = editions.map(edition => loadEditionDataForDate(datePrefix, edition));
      
      try {
        const results = await Promise.all(promises);
        const combinedData = {};
        
        // Combine all edition data into unified structure
        results.forEach(result => {
          if (result.user_data && typeof result.user_data === 'object') {
            for (const [filename, fileData] of Object.entries(result.user_data)) {
              combinedData[filename] = fileData;
            }
          }
        });
        
        return {
          snapshot: {
            status: combinedData,
            monitoring_date: datePrefix
          },
          datePrefix: datePrefix
        };
      } catch (err) {
        console.error('Failed to load edition data:', err);
        throw new Error(`Failed to load edition data: ${err.message}`);
      }
    }

    // Process unified status data into display structure
    function processUnifiedStatus(unifiedStatus, datePrefix) {
      console.log('Processing unified status:', unifiedStatus);
      
      const editionStructure = {
        '01Kokan': [],
        '02Satara': [],
        '03Sangli': [],
        '04Kolhapur': [],
        '05Pullout': []
      };

      if (!unifiedStatus || !unifiedStatus.status) {
        console.log('No status data found in unifiedStatus');
        return editionStructure;
      }

      const statusData = unifiedStatus.status;
      console.log('Status data keys:', Object.keys(statusData));
      
      // Group files by edition and issue type
      const filesByEditionAndIssue = {};

      for (const filename in statusData) {
        const fileData = statusData[filename];
        
        // Skip if no meaningful data
        if (!fileData) continue;
        
        console.log('Processing file:', filename, fileData);

        // Determine edition from filename
        let edition = '';
        let issueType = 'Other Issue';
        let prefix = '';

        // Extract prefix from filename
        const parts = filename.split('-');
        if (parts.length >= 3) {
          prefix = parts[1] + '-' + parts[2];
        } else {
          prefix = filename.replace('.pdf', '');
        }

        // IDENTIFY PULLOUT FILES FIRST
        if (filename.includes('PUL-')) {
          edition = '05Pullout';
          
          // Determine specific pullout type
          if (filename.includes('KHK')) {
            issueType = 'Kolhapur-City Pullout';
          } else if (filename.includes('KHD')) {
            issueType = 'Kolhapur-District Pullout';
          } else if (filename.includes('RTH')) {
            issueType = 'Kokan-Ratnagiri Pullout';
          } else if (filename.includes('SDH')) {
            issueType = 'Kokan-Sindhudurg Pullout';
          } else if (filename.includes('SNH')) {
            issueType = 'Sangli Pullout';
          } else if (filename.includes('PHL')) {
            issueType = 'Satara-Phaltan Pullout';
          } else if (filename.includes('KRD')) {
            issueType = 'Satara-Karad Pullout';
          } else if (filename.includes('WKM')) {
            issueType = 'Satara-Wai Pullout';
          } else if (filename.includes('MNTH')) {
            issueType = 'Saransh Issue (Sunday)';
          } else {
            issueType = 'Pullout';
          }
        }
        // Regular edition files
        else if (filename.includes('RTN') || filename.includes('RTH') || filename.includes('SDH')) {
          edition = '01Kokan';
          if (filename.includes('LK-RTN')) issueType = 'Main Issue';
          else if (filename.includes('RTH')) issueType = 'Ratnagiri Hello';
          else if (filename.includes('SDH')) issueType = 'Sindhudurg Hello';
        } else if (filename.includes('SAT') || filename.includes('STH')) {
          edition = '02Satara';
          if (filename.includes('LK-SAT')) issueType = 'Main Issue';
          else if (filename.includes('STH')) issueType = 'Hello Issue';
        } else if (filename.includes('SNG') || filename.includes('SNH')) {
          edition = '03Sangli';
          if (filename.includes('LK-SNG')) issueType = 'Main Issue';
          else if (filename.includes('SNH')) issueType = 'Hello Issue';
        } else if (filename.includes('KOL') || filename.includes('KHK') || filename.includes('KHD')) {
          edition = '04Kolhapur';
          if (filename.includes('LK-KOL')) issueType = 'Main Issue';
          else if (filename.includes('KHK')) issueType = 'City Hello';
          else if (filename.includes('KHD')) issueType = 'District Hello (Rare)';
        } else {
          // Skip files that don't match any known pattern
          console.log('Skipping unknown file:', filename);
          continue;
        }

        console.log(`File ${filename} -> Edition: ${edition}, Issue: ${issueType}`);

        // Initialize edition and issue type in our structure
        if (!filesByEditionAndIssue[edition]) {
          filesByEditionAndIssue[edition] = {};
        }
        if (!filesByEditionAndIssue[edition][issueType]) {
          filesByEditionAndIssue[edition][issueType] = {
            prefix: prefix,
            files: []
          };
        }

        // Add file to the appropriate group
        filesByEditionAndIssue[edition][issueType].files.push({
          filename: filename,
          data: fileData
        });
      }

      console.log('Files grouped by edition and issue:', filesByEditionAndIssue);

      // Build the edition structure with section titles
      for (const edition in filesByEditionAndIssue) {
        // Get all issue types for this edition and sort them
        const issueTypes = Object.keys(filesByEditionAndIssue[edition]);
        
        // Sort issue types: Main Issue first, then Hello issues, then others
        issueTypes.sort((a, b) => {
          const order = {
            'Main Issue': 1,
            'Ratnagiri Hello': 2,
            'Sindhudurg Hello': 3,
            'Hello Issue': 4,
            'City Hello': 5,
            'District Hello (Rare)': 6,
            'Saransh Issue (Sunday)': 7,
            'Kolhapur-City Pullout': 8,
            'Kolhapur-District Pullout': 9,
            'Kokan-Ratnagiri Pullout': 10,
            'Kokan-Sindhudurg Pullout': 11,
            'Sangli Pullout': 12,
            'Satara-Phaltan Pullout': 13,
            'Satara-Karad Pullout': 14,
            'Satara-Wai Pullout': 15,
            'Pullout': 16,
            'Other Issue': 99
          };
          return (order[a] || 100) - (order[b] || 100);
        });

        // Add issues in sorted order
        for (const issueType of issueTypes) {
          const issueData = filesByEditionAndIssue[edition][issueType];
          const pageCount = issueData.files.length;
          
          // Add section title
          const isPullout = edition === '05Pullout';
          editionStructure[edition].push({
            type: isPullout ? 'pullout_title' : 'section_title',
            text: `${issueType} (${pageCount} Pages) - ${issueData.prefix}`
          });

          // Sort files by page number
          issueData.files.sort((a, b) => {
            const pageNumA = parseInt(a.filename.match(/-(\d+)\.pdf$/)?.[1] || '0');
            const pageNumB = parseInt(b.filename.match(/-(\d+)\.pdf$/)?.[1] || '0');
            return pageNumA - pageNumB;
          });

          // Add files in page order
          issueData.files.forEach(fileInfo => {
            editionStructure[edition].push({
              file: fileInfo.filename,
              title: fileInfo.data.title || '',
              edit: fileInfo.data.edit || '',
              icd: fileInfo.data.icd || '',
              ok: fileInfo.data.ok || "Wait", // Default to "Wait" if not set
              time: fileInfo.data.time || 'N/A'
            });
          });
        }
      }

      // Remove empty editions
      Object.keys(editionStructure).forEach(edition => {
        if (editionStructure[edition].length === 0) {
          delete editionStructure[edition];
        }
      });

      console.log('Final edition structure:', editionStructure);
      return editionStructure;
    }

    // Render status cards from processed data
    function renderStatusCards(snapshotData) {
      clearAllTabContents();
      
      if (!snapshotData || !snapshotData.snapshot) {
        document.getElementById('tab-kokan').innerHTML = '<div class="error">No data available for this date</div>';
        document.getElementById('tab-kokan').classList.add('active');
        return;
      }

      const { snapshot, datePrefix } = snapshotData;

      // Update current date display with the date from column A
      currentDatePrefix = datePrefix;
      currentDateEl.textContent = formatDisplayDate(datePrefix);

      // Process the unified status structure
      const editionStructure = processUnifiedStatus(snapshot, datePrefix);

      // Helper function to convert the full filename to abbreviated version
      function getAbbreviatedFilename(fullFileName) {
        const parts = fullFileName.split('-');
        
        // For pullout files, show specific abbreviations
        if (fullFileName.includes('PUL-')) {
          if (parts.length >= 4) {
            // Format: P-KHK-01 (P for Pullout, then the specific code, then page number)
            const pulloutCode = parts[2]; // KHK, KHD, RTH, etc.
            const pageNum = parts[3].replace('.pdf', '');
            return `P-${pulloutCode}-${pageNum}`;
          }
        }
        
        // For regular files
        if (parts.length >= 3) {
          let suffix = parts.slice(-2).join('-');
          if (suffix.endsWith('.pdf')) suffix = suffix.slice(0, -4);
          return suffix;
        }
        
        return fullFileName;
      }

      // Check if we have pullout data and update tab visibility
      const hasPulloutData = editionStructure.hasOwnProperty('05Pullout') && editionStructure['05Pullout'].length > 0;
      const pulloutTab = document.getElementById('tab-pullout-btn');
      
      if (pulloutTab) {
        pulloutTab.style.display = hasPulloutData ? 'flex' : 'none';
      }

      // Render each edition to its respective tab
      const tabMapping = {
        '01Kokan': 'kokan',
        '02Satara': 'satara', 
        '03Sangli': 'sangli',
        '04Kolhapur': 'kolhapur',
        '05Pullout': 'pullout'
      };

      for (const editionKey in editionStructure) {
        const tabId = tabMapping[editionKey];
        if (!tabId) continue;
        
        const tabContent = document.getElementById(`tab-${tabId}`);
        if (!tabContent) continue;
        
        const rows = editionStructure[editionKey];
        
        // Create card for this edition
        const card = document.createElement('div');
        card.className = 'card';

        const title = document.createElement('h3');
        title.textContent = editionKey.replace('01', '').replace('02', '').replace('03', '').replace('04', '').replace('05', '');
        card.appendChild(title);

        const table = document.createElement('table');
        table.className = 'checklist-table';

        rows.forEach(item => {
          // Group titles (e.g., "Main Issue", "Pullout")
          if (item && typeof item === 'object' && (item.type === 'section_title' || item.type === 'pullout_title')) {
            const tr = document.createElement('tr');
            tr.className = item.type === 'pullout_title' ? 'pullout-group-title-row' : 'issue-group-title-row';
            const td = document.createElement('td');
            td.colSpan = 6;
            td.textContent = item.text;
            tr.appendChild(td);
            table.appendChild(tr);
            return;
          }

          // Regular PDF rows
          if (item && item.file) {
            const abbreviatedFileName = getAbbreviatedFilename(item.file);
            const tr = document.createElement('tr');

            // File name
            const fileTd = document.createElement('td');
            fileTd.className = 'filename-col';
            fileTd.textContent = abbreviatedFileName;
            fileTd.title = item.file;

            // Title
            const titleTd = document.createElement('td');
            titleTd.className = 'title-col';
            titleTd.textContent = item.title || '';

            // Edit
            const editTd = document.createElement('td');
            editTd.className = 'edit-col';
            editTd.textContent = item.edit || '';

            // ICD
            const icdTd = document.createElement('td');
            icdTd.className = 'icd-col';
            icdTd.textContent = item.icd || '';

            // CORRECTED: Status with proper dot colors
            const statusTd = document.createElement('td');
            statusTd.className = 'status-col';
            statusTd.innerHTML = renderStatusDot(item.ok);

            // Time
            const timeTd = document.createElement('td');
            timeTd.className = 'time-col';
            timeTd.textContent = item.ok === "OK" ? (item.time || 'N/A') : 'N/A';

            // Append all columns
            tr.appendChild(fileTd);
            tr.appendChild(titleTd);
            tr.appendChild(editTd);
            tr.appendChild(icdTd);
            tr.appendChild(statusTd);
            tr.appendChild(timeTd);
            table.appendChild(tr);
          }
        });

        card.appendChild(table);
        tabContent.appendChild(card);
      }

      // Activate the previously active tab or first available tab
      const activeTabElement = document.getElementById(`tab-${currentActiveTab}-btn`);
      if (activeTabElement && activeTabElement.style.display !== 'none' && document.getElementById(`tab-${currentActiveTab}`).children.length > 0) {
        switchTab(currentActiveTab);
      } else {
        // Find first tab with content
        const tabs = ['kokan', 'satara', 'sangli', 'kolhapur', 'pullout'];
        for (const tabId of tabs) {
          const tabBtn = document.getElementById(`tab-${tabId}-btn`);
          const tabContent = document.getElementById(`tab-${tabId}`);
          if (tabBtn && tabBtn.style.display !== 'none' && tabContent && tabContent.children.length > 0) {
            switchTab(tabId);
            break;
          }
        }
      }
    }

    // Navigate to a specific date
    async function navigateToDate(index) {
      if (index < 0 || index >= availableDates.length) return;
      
      currentDateIndex = index;
      const datePrefix = availableDates[index];
      
      clearError();
      showLoading(`Loading data for ${formatDisplayDate(datePrefix)}...`);
      
      try {
        // Use edition-specific data loading
        const snapshotData = await loadAllEditionData(datePrefix);
        hideLoading();
        renderStatusCards(snapshotData);
        
        // Update navigation buttons
        updateNavigationButtons();
      } catch (err) {
        hideLoading();
        showError(err.message);
      }
    }

    // Update navigation buttons state
    function updateNavigationButtons() {
      // Left arrow button (←) disabled when at the most recent date (last index)
      prevDateBtn.disabled = currentDateIndex >= availableDates.length - 1;
      // Right arrow button (→) disabled when at the oldest date (index 0)
      nextDateBtn.disabled = currentDateIndex <= 0;
    }

    // Start automatic synchronization
    function startAutoSync() {
      // Clear any existing interval
      if (syncIntervalId) {
        clearInterval(syncIntervalId);
      }
      
      // Set up new interval for syncing every 30 seconds
      syncIntervalId = setInterval(async () => {
        if (currentDateIndex >= 0 && currentDateIndex < availableDates.length) {
          try {
            const datePrefix = availableDates[currentDateIndex];
            // Use edition-specific data loading
            const snapshotData = await loadAllEditionData(datePrefix);
            renderStatusCards(snapshotData);
          } catch (err) {
            console.warn('Auto-sync failed:', err.message);
          }
        }
      }, 30000);
    }

    // Stop automatic synchronization
    function stopAutoSync() {
      if (syncIntervalId) {
        clearInterval(syncIntervalId);
        syncIntervalId = null;
      }
    }

    // Find index of a date in available dates array
    function findDateIndex(datePrefix) {
      return availableDates.findIndex(date => date === datePrefix);
    }

    // Initialize the viewer
    async function initializeViewer() {
      try {
        showLoading('Loading default date...');
        
        // Initialize tabs
        initializeTabs();
        
        // 1. Get default date from Settings sheet
        const defaultDate = await fetchDefaultDate();
        
        // 2. Get all available dates
        availableDates = await fetchAvailableDates();
        
        if (availableDates.length === 0) {
          hideLoading();
          showError('No saved snapshots found');
          return;
        }
        
        // 3. Find the default date in available dates, or use most recent
        let targetDateIndex = findDateIndex(defaultDate);
        if (targetDateIndex === -1) {
          // Default date not found, use most recent date
          targetDateIndex = 0;
        }
        
        // 4. Load the target date
        await navigateToDate(targetDateIndex);
        
        // 5. Start auto-sync
        startAutoSync();
        
      } catch (err) {
        hideLoading();
        showError('Failed to initialize: ' + err.message);
      }
    }

    // Event listeners for navigation
    prevDateBtn.addEventListener('click', () => {
      // Left arrow button (←) - go to previous (older) date
      if (currentDateIndex < availableDates.length - 1) {
        navigateToDate(currentDateIndex + 1);
      }
    });

    nextDateBtn.addEventListener('click', () => {
      // Right arrow button (→) - go to next (more recent) date
      if (currentDateIndex > 0) {
        navigateToDate(currentDateIndex - 1);
      }
    });

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', initializeViewer);
    
    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
      stopAutoSync();
    });
  </script>
</body>
</html>